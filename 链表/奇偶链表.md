------

# 链表奇偶重排（Odd Even Linked List）

## 📌 题目描述

给定一个单链表的头节点 `head`，要求将链表中**奇数索引位置**的节点排列在前面，**偶数索引位置**的节点排列在后面，并保持它们在原链表中的**相对顺序**。

- 第 1 个节点视为奇数索引。
- 要求时间复杂度为 `O(n)`，空间复杂度为 `O(1)`。

------

## 🔍 算法思想：双指针在链表上的应用

虽然该问题归类于“链表操作”，但本质上使用的是典型的 **双指针（Two Pointers）** 思想，只不过操作的是**链表节点指针**而不是数组下标。

### 双指针定义对照：

| 指针   | 含义                 |
| ------ | -------------------- |
| `odd`  | 指向当前奇数索引节点 |
| `even` | 指向当前偶数索引节点 |

它们在遍历时交替向前推进，分别连接奇偶索引节点，最终重组成新的链表结构。

✅ **思想一致于数组中双指针分组、分类处理的策略。**

------

## ❌ 错误解法分析：使用额外队列空间

### 原思路

使用 `Deque` 缓存偶数位置节点，遍历链表时手动记录索引，并把奇数节点连接成链表，最后再把偶数节点拼接上去。

### 存在的问题

1. ❌ **空间复杂度不是 O(1)**，使用了额外队列。
2. ❌ **索引判断复杂**，需要手动维护 index。
3. ❌ **结尾节点处理繁琐**，容易漏处理节点。

------

## ✅ 正确解法：双指针法（Two Pointers）

### 思路

- 使用两个指针 `odd` 和 `even` 分别处理奇偶索引的链表；
- 遍历时通过 `odd.next = even.next` 和 `even.next = odd.next` 实现奇偶节点的分离；
- 遍历结束后将奇数部分的末尾 `odd.next` 连接到偶数链表头部。

### Java 实现

```java
class Solution {
    public ListNode oddEvenList(ListNode head) {
        if (head == null || head.next == null) return head;

        ListNode odd = head;             // 奇数链头
        ListNode even = head.next;      // 偶数链头
        ListNode evenHead = even;       // 保存偶数链头以拼接

        while (even != null && even.next != null) {
            odd.next = even.next;       // 奇 -> 下一个奇
            odd = odd.next;

            even.next = odd.next;       // 偶 -> 下一个偶
            even = even.next;
        }

        odd.next = evenHead;            // 拼接偶数链到奇数链尾
        return head;
    }
}
```

------

## 🔍 为什么 `while (even != null && even.next != null)` 可以遍历完整个链表？

- 每次循环操作都访问一对节点（奇 + 偶）；
- `odd` 和 `even` 交替向前推进，**所有节点都被访问到**；
- 一旦偶数链或其下一个节点为空，说明链表已被完全处理，退出循环。

------

## ✅ 时间与空间复杂度分析

- **时间复杂度**：`O(n)`，每个节点只访问一次。
- **空间复杂度**：`O(1)`，只使用常数级指针变量。

------

## 📌 总结

| 点       | 内容                                                         |
| -------- | ------------------------------------------------------------ |
| 核心思想 | 使用双指针分别遍历奇偶节点                                   |
| 技术关键 | odd/even 分别指向链表的两个子序列                            |
| 重要细节 | 使用 `even != null && even.next != null` 作为循环条件避免空指针 |
| 算法归类 | ✅ 双指针法（在链表结构上的应用）                             |
| 最佳实践 | 避免用数组或队列存储，保持 O(1) 空间                         |

------

