------

# 机器人不同路径问题

一个机器人位于一个 m x n 网格的左上角（起始点为 `Start`），它每次只能向右或向下移动一步，目标是到达网格的右下角（`Finish`）。问总共有多少条不同的路径？

------

## ✅ 方法一：二维数组动态规划

### 💡 思路

- `dp[i][j]` 表示从起点走到坐标 `(i, j)` 的路径总数。

- 状态转移方程：

  ```
  dp[i][j] = dp[i-1][j] + dp[i][j-1]
  ```

- 边界条件：

  - 第一行所有 `dp[0][j] = 1`（只能一直向右走）
  - 第一列所有 `dp[i][0] = 1`（只能一直向下走）

### ✅ 正确代码

```java
public int uniquePaths(int m, int n) {
    int[][] dp = new int[m][n];
    for (int i = 0; i < m; i++) dp[i][0] = 1;
    for (int j = 0; j < n; j++) dp[0][j] = 1;

    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
}
```

------

## ✅ 方法二：一维数组空间优化

### 💡 思路

- 由于 `dp[i][j]` 只与上一行 `dp[i-1][j]` 和左边的 `dp[i][j-1]` 有关，因此可将二维数组压缩为一维。
- 用一个数组 `dp[j]` 表示“当前行”的状态：
  - `dp[j]` 表示上方的值（还未被覆盖）
  - `dp[j - 1]` 表示左边的值（本轮更新已完成）

### 🧠 为什么 `j` 从 1 开始？

- `dp[0]` 表示最左列，从起点一路向下，路径始终为 1，**不需更新**；
- 其他位置需要合并“左”和“上”的路径数，因此从 `j = 1` 开始。

### ✅ 优化代码

```java
public int uniquePaths(int m, int n) {
    int[] dp = new int[n];
    Arrays.fill(dp, 1);

    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[j] += dp[j - 1];
        }
    }
    return dp[n - 1];
}
```

------

## 🔍 关键总结

- ✅ 第一行 & 第一列初始化为 `1` 是因为只有一条路径（直走）；
- ✅ 二维数组转一维数组时，每个 `dp[j] = 上 + 左`，即当前值 + 左边值；
- ✅ `dp[0]` 永远为 1，因为是最左侧，不需要加上左边路径；
- ✅ 遍历时从 `j = 1` 开始是为了防止重复更新不该更新的最左列。

------

## 📚 拓展练习建议

- 62. 不同路径（当前题）
- 63. 不同路径 II（有障碍）
- 64. 最小路径和
-  剑指 Offer 47. 礼物的最大价值

------

