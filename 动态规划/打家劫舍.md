------

# 打家劫舍问题（House Robber）

## 🧩 问题描述

你是一个专业的小偷，计划在一夜之间偷窃沿街的房屋。每间房屋中藏有一定的现金。但有一个限制条件：

> **相邻的两间房子不能在同一晚上被偷，否则会触发报警系统。**

给定一个代表每个房屋存放金额的非负整数数组 `nums`，请计算在不触动报警装置的前提下，**一夜之间你能够偷窃到的最高金额**。

------

## 💡 解题思路

该问题是一个经典的**动态规划问题**，核心思想是：

- 对于第 `i` 间房子，有两个选择：
  - **偷**当前房子，那么前一间房子 `i-1` 不能偷。
  - **不偷**当前房子，那么金额取决于前一间房子能偷到的最大值。

### 状态表示

定义状态数组 `dp[i]` 表示偷到第 `i` 间房子为止，能获得的最大金额。

### 状态转移方程

```
dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])
```

### 边界情况

- `dp[0] = nums[0]`
- `dp[1] = max(nums[0], nums[1])`

------

## ✅ 空间优化写法（Java）

由于 `dp[i]` 只依赖 `dp[i - 1]` 和 `dp[i - 2]`，因此可以使用两个变量优化空间复杂度为 O(1)：

```java
public class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if (n == 0) return 0;
        if (n == 1) return nums[0];

        int prev2 = nums[0];                     // dp[i - 2]
        int prev1 = Math.max(nums[0], nums[1]);  // dp[i - 1]

        for (int i = 2; i < n; i++) {
            int curr = Math.max(prev1, prev2 + nums[i]);
            prev2 = prev1;
            prev1 = curr;
        }

        return prev1;
    }
}
```

------

## 🧪 示例

输入：

```java
int[] nums = {2, 7, 9, 3, 1};
```

输出：

```
12
```

解释：偷第 1、3、5 间房子，金额为 2 + 9 + 1 = **12**

------

## 📌 时间与空间复杂度分析

| 项目       | 复杂度         |
| ---------- | -------------- |
| 时间复杂度 | O(n)           |
| 空间复杂度 | O(1)（优化后） |



------