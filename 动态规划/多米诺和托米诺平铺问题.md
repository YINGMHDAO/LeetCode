------

#  多米诺和托米诺平铺

## 📌 题目描述

给定整数 `n`，求用两种瓷砖（2×1 的**多米诺** 和形如 L 的**托米诺**，支持旋转）将 `2×n` 的面板铺满的方法数。结果对 `10⁹ + 7` 取模。

------

## 🔍 题意理解

- 多米诺砖：可以竖放（1列2格）或横放（2列1格）
- 托米诺砖（L 形）：每块占 3 格，有 4 种旋转方向
- 要求每格被恰好覆盖，不能重叠或遗漏

------

## 🧮 解法思路

### 🎯 状态定义

设 `f(n)` 表示铺满 `2×n` 面板的方案数。

### ✅ 正确递推公式：

```
f(n) = f(n-1) + f(n-2) + 2 * (f(0) + f(1) + ... + f(n-3))
```

解释：

- `f(n-1)`：末尾加一个竖着的多米诺
- `f(n-2)`：末尾加两个横着的多米诺
- `2 * sum(...)`：以两块托米诺组成的对称结构（2×3）为末尾的组合，总共两种方向，对前 `0..n-3` 长度的所有铺法生效

------

## 🧠 初始条件

```
f(0) = 1  // 空面板也算一种合法铺法（什么都不放）
f(1) = 1  // 竖着放一块多米诺
f(2) = 2  // 两块竖的 or 两块横的
```

------

## 🛠️ 实现技巧：维护累加前缀和

因为每次都需要 `f(0) + ... + f(n-3)`，若暴力遍历会 TLE，所以需要用变量 `sum` 来记录前缀和并动态更新：

```java
sum = sum + f(n-2)
```

------

## 💡 滚动变量优化版本（终极写法）

```java
class Solution {
    private static final int MOD = 1_000_000_007;

    public int numTilings(int n) {
        if (n == 0) return 1;
        if (n == 1) return 1;
        if (n == 2) return 2;

        long f0 = 1, f1 = 1, f2 = 2, sum = 1;

        for (int i = 3; i <= n; i++) {
            long f3 = (f2 + f1 + 2 * sum) % MOD;
            sum = (sum + f1) % MOD;
            f0 = f1;
            f1 = f2;
            f2 = f3;
        }

        return (int) f2;
    }
}
```

------

## 🧪 示例验证

| n    | f(n) |
| ---- | ---- |
| 0    | 1    |
| 1    | 1    |
| 2    | 2    |
| 3    | 5    |
| 4    | 11   |
| 5    | 24   |
| 6    | 53   |
| 7    | 117  |

------

## ❗ 易错点总结

- ❌ `f(n) = f(n-1) + f(n-2) + 2*f(n-3)` 是错误的简化版，只适用于部分情况
- ✅ 正确公式是累加 `f(0)` 到 `f(n-3)`，不能遗漏其他组合
- ❌ 空面板不是 0，而是 1（表示“无操作也算合法”）
- ✅ 注意使用 `% MOD` 来避免溢出

------

## 📈 时间与空间复杂度

- 时间复杂度：`O(n)`
- 空间复杂度：`O(1)`（使用滚动变量）

------

## 🧩 思维升级提示

如果要处理 **更多砖型**、**不规则形状**、或者 **3×n 的铺法问题**，则需要：

- 多状态转移方程
- 或者二维 DP 状态表示（比如位运算表示每列状态）

------

