------

# 最小花费爬楼梯

## 🧩 题目描述：最小花费爬楼梯

给你一个整数数组 `cost`，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请计算并返回达到楼梯顶部的最低花费。

------

## ✅ 解法一：标准动态规划（空间 O(n)）

```java
public int minCostClimbingStairs(int[] cost) {
    int n = cost.length;
    int[] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = 0;
    for (int i = 2; i <= n; i++) {
        dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
    }
    return dp[n];
}
```

- `dp[i]` 表示到达第 `i` 个台阶的最小花费
- 从 `dp[2]` 开始迭代，考虑从 `i-1` 或 `i-2` 上来的路径

**时间复杂度**：O(n)
 **空间复杂度**：O(n)

------

## ✅ 解法二：空间优化（空间 O(1)）

当我们只关心最终结果，不关注路径，中间状态仅依赖最近两个值时，可以使用两个变量替代整个 `dp[]` 数组：

```java
public int minCostClimbingStairs(int[] cost) {
    int prev = 0, curr = 0;
    for (int i = 2; i <= cost.length; i++) {
        int next = Math.min(curr + cost[i - 1], prev + cost[i - 2]);
        prev = curr;
        curr = next;
    }
    return curr;
}
```

**时间复杂度**：O(n)
 **空间复杂度**：O(1) ✔️（最优）

------

## 📌 动态规划空间优化总结

### ✅ 可以优化空间的场景：

- 只需要最终结果，不需要中间过程
- 状态转移仅依赖于最近的有限几个状态（如前 1~2 个）
- 例如：
  - 斐波那契数列
  - 最小花费爬楼梯
  - 打家劫舍
  - 最大子序和（Kadane’s 算法）

### ❌ 不适合空间优化的场景：

- 需要记录中间过程以恢复路径
- 状态转移依赖多个/不固定状态
- 如：
  - 最长公共子序列（要输出路径）
  - 0-1 背包（需要记录选项）
  - 编辑距离（带插入/删除操作）

------

## ✅ 实用口诀总结

> **“只看结果不看过程，前状态少可优化。”**
>  ➜ 如果你只关心最终结果，且每个状态仅依赖最近的少量状态，可以用有限变量滚动保存，省去 `dp[]` 数组，优化空间。

------

