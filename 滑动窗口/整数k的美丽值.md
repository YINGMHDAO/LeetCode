------

### 整数的 k 美丽值问题

#### ✅ 题目描述

给定一个整数 `num` 和一个整数 `k`，求 `num` 中满足以下条件的**子字符串**个数：

- 子字符串长度为 `k`；
- 子字符串可以整除 `num`；
- 允许前导零，但 `0` 不能整除任何值。

------

#### 🔍 示例讨论

##### 示例1：

输入：`num = 240`, `k = 2`
 子串包括：`24`, `40`

- `24` 能整除 `240` ✅
- `40` 不能整除 `240` ❌

##### 示例2：

输入：`num = 430043`, `k = 2`
 子串包括：`43`, `30`, `00`, `04`, `43`

- `43` ✅
- `30` ❌
- `00` ❌（不能为0）
- `04` ✅
- `43` ✅
   输出为 `3`

------

#### 🚫 错误实现示例

```java
// 错误逻辑：使用滑动窗口加减法会出错
windowVal = windowVal * 10 + (s.charAt(i) - '0');
if (i >= k) windowVal -= (s.charAt(i - k) - '0') * pow10;
```

> ⚠️ 当有前导0或多位数时，这种做法会产生错误的 `windowVal` 值（比如 240 情况下会变成 220）。

------

#### ✅ 正确实现方案

```java
public int divisorSubstrings(int num, int k) {
    String s = String.valueOf(num);
    int res = 0;
    for (int i = 0; i <= s.length() - k; i++) {
        int val = Integer.parseInt(s.substring(i, i + k));
        if (val != 0 && num % val == 0) {
            res++;
        }
    }
    return res;
}
```

- 使用字符串 `substring()` 精确截取子串；
- 转换为整数后再判断是否能整除；
- 简洁、安全、不会因前导零出错。

------

### ✅ 总结

| 实现方式       | 简单 | 正确性 | 性能 | 推荐程度 |
| -------------- | ---- | ------ | ---- | -------- |
| 滑动窗口加减法 | ❌    | ❌      | ✅    | ⭐        |
| 字符串截取法   | ✅    | ✅      | 良好 | ⭐⭐⭐⭐⭐    |

------

