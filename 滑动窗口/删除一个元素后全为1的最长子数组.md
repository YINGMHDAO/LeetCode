------

# 最长1的子数组（删除一个元素）

## 🧠 题目描述

给定一个二进制数组 `nums`，你需要**从中删掉一个元素**，然后返回删掉这个元素后的数组中，**只包含 1 的最长非空子数组的长度**。

- 如果不存在这样的子数组，请返回 `0`。

### 示例

```text
输入: nums = [1,1,0,1]
输出: 3
解释: 删除 nums[2] = 0 后，数组变为 [1,1,1]，最长连续1的子数组长度为 3。
```

------

## 🚀 解法：滑动窗口（Two Pointers）

### 解题思路

- 使用滑动窗口 `[left, right]`，记录窗口中最多包含一个 `0` 的子数组。
- 每当窗口中的 `0` 的数量超过 1，就收缩左边界。
- 每次更新当前窗口中最多 `1` 的子数组长度（不含第二个 `0`）。

### ✅ Java 实现

```java
class Solution {
    public int longestSubarray(int[] nums) {
        int left = 0, zeroCount = 0, maxLen = 0;
        for (int right = 0; right < nums.length; right++) {
            if (nums[right] == 0) zeroCount++;

            while (zeroCount > 1) {
                if (nums[left++] == 0) zeroCount--;
            }

            maxLen = Math.max(maxLen, right - left);
        }
        return maxLen;
    }
}
```

------

## ⚠️ 边界情况分析

- **全为1的情况**：如 `[1,1,1,1]`，删除任意一个元素后剩下的最长连续1是 `n - 1`。
- **全为0的情况**：如 `[0,0,0]`，最多删除1个0，仍然没有连续1，返回 `0`。
- 代码中使用 `right - left` 而非 `right - left + 1`，恰好满足“删除一个元素”的语义（窗口中允许最多一个 `0`）。

------

## ⏱️ 复杂度分析

| 复杂度     | 值     |
| ---------- | ------ |
| 时间复杂度 | `O(n)` |
| 空间复杂度 | `O(1)` |

------

## ✅ 总结

- 本题适合用**滑动窗口**来解决。
- 不需要使用额外的数组或前缀和，当前实现已经是最优。
- 可拓展为“允许删除 `k` 个元素”问题。

------

如果后续你想实现一个通用的版本，支持删除任意 `k` 个元素，也可以通过调整 `zeroCount > k` 来实现。

------