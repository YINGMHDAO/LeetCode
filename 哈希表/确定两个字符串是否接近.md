# 确定两个字符串是否接近

## 📌 一、问题背景

在力扣的一道题中，要求判断两个字符串是否“接近”，定义如下：

- 操作 1：可以交换字符串中任意两个已存在的字符。
- 操作 2：可以将字符串中一种字符的所有出现变为另一种已存在字符，反之亦然。

题目要求判断 word1 是否可以通过任意次上述操作变为 word2。

---

## 🧠 二、初步解法与优化

### ✅ 初步思路（HashMap 版本）

1. 使用两个 `HashMap<Character, Integer>` 分别统计两个字符串中字符出现的频率。
2. 比较两个字符串是否包含相同的字符集合。
3. 比较两个字符串中字符频率的分布是否一致（通过排序 frequency list）。

```java
Map<Character, Integer> countMap1 = new HashMap<>();
Map<Character, Integer> countMap2 = new HashMap<>();
// ... 遍历统计，排序比较
```

### 🔧 优化思路（数组版）

由于字符串只包含 26 个小写字母，可以用 `int[26]` 来替代哈希表，大幅提升性能：

```java
int[] freq1 = new int[26];
int[] freq2 = new int[26];
// ... 统计并排序后比较
```

- 判断字符集一致：看两个 freq 数组对应位置是否都为 0 或都不为 0。
- 判断频率集合一致：对 freq1 和 freq2 排序后是否相等。

---

## 🎯 三、从方法到思想：算法分类 ≠ 工具限定

### ✅ 误区澄清

> 哈希表题目 ≠ 必须使用 HashMap、dict、unordered_map 等具体数据结构。

**正确理解：**

- 哈希表算法题 = 利用**哈希映射的思维模型**解决问题
- 用什么工具取决于场景：`HashMap`、`Set`、`数组` 都可以实现这种映射

---

## 🔍 四、哈希表算法思想的本质

| 思维要点      | 说明                                                                 |
|---------------|----------------------------------------------------------------------|
| 映射关系       | 将元素映射到另一个值（如字符 ➝ 频率，数字 ➝ 出现位置）                |
| 快速查找       | 支持 O(1) 时间的查找、插入、删除                                      |
| 工具灵活       | 可以使用 HashMap，也可以使用数组、Set，只要能表达映射和快速查找即可   |
| 优化场景       | 如果 key 范围有限（如 0~25 的字符），优先考虑数组代替哈希表           |

---

## 💡 五、实战建议

| 场景                        | 工具选择            | 理由                                 |
|-----------------------------|---------------------|--------------------------------------|
| 小写字母统计                | `int[26]`           | 快速、空间固定、无需哈希开销         |
| 字符种类判断（是否出现）    | `boolean[26]`       | 判断某个字符是否存在                 |
| 字符集未知或范围大          | `HashMap`           | 动态键值映射                         |
| 频率分布比较（多集合）      | `Map<Integer, Integer>` 或排序 | 判断频率分布是否一致 |

---

## ✅ 六、一句话总结

> “哈希表算法”是一种**思维方式**，不是特指你用 HashMap 去写代码，而是用“映射 + 快速查找”的思想建模并解决问题。

---
