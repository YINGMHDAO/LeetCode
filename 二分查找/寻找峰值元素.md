# 寻找峰值元素

## 🧠 题目描述

> 峰值元素是指其值严格大于左右相邻元素的元素。
>
> 给定一个整数数组 `nums`，找到一个 **任意的** 峰值元素并返回其索引。
>
> 要求：**时间复杂度为 O(log n)**。

> 特殊条件：假设 `nums[-1] = nums[n] = -∞`。

---

## 🔍 解题思路：二分查找

通过 **比较中间元素与右边元素** 的大小关系，决定查找方向：

1. 如果 `nums[mid] < nums[mid + 1]`，峰值一定在右边。
2. 否则，峰值一定在左边（包括 `mid`）。
3. 最终 `left == right` 时，指针即指向峰值。

---

## ✅ Java 实现

```java
class Solution {
    public int findPeakElement(int[] nums) {
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < nums[mid + 1]) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return left;
    }
}
```

---

## 📈 为什么只比较右边就能找到峰值？

因为：

- 如果 `nums[mid] < nums[mid + 1]`，即处于上坡，**继续往右走一定能找到峰值**。
- 如果 `nums[mid] > nums[mid + 1]`，说明可能已经在下降趋势，峰值在左边或 `mid` 本身。

题目假设两端为 `-∞`，保证了：

> **一旦出现上升趋势，最终一定会达到一个局部峰值**。

### 📌 可视化例子：

```java
nums = [1, 3, 5, 4, 2]
```

趋势图：

```
1 → 3 → 5 → 4 → 2

     峰值
```

不论你从哪里开始，只要跟着“上升方向”走，最终一定会遇到“变下降”的地方，即峰值。

---

## 🧠 边界问题分析

错误写法（越界风险）：

```java
if (nums[mid] > nums[mid - 1] && nums[mid] > nums[mid + 1])
```

当 `mid = 0` 或 `mid = n-1` 时会越界访问。

### 🚨 避免方式：
- 只使用 `nums[mid] < nums[mid + 1]` 判断
- 不访问 `mid - 1` 和 `mid + 1` 之外的边界

---

## ✅ 时间复杂度

- 每次查找排除一半区域
- **时间复杂度：O(log n)**

---

## ✅ 空间复杂度

- 只使用常量级变量
- **空间复杂度：O(1)**

---

## 📌 总结

- 本题可以通过二分查找实现 O(log n) 的查找峰值算法。
- 关键在于利用“变大的方向最终一定能到达峰值”的数学特性。
- 推荐写法稳定、健壮，不会越界。